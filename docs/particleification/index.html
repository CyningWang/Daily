<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>图片粒子化</title>
    <style>
        body{
            height: 100%;
            background: #000;
        }
        #canvas{
            position: absolute;
            display: block;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            margin: auto;
            z-index: -1;
            box-shadow: 0 0 10px 0 #fff inset;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="600" height="400">您的浏览器不支持canvas.</canvas>
    <script>
        (function () {
            // 1. 常规套路，获取canvas,context
            var canvas = document.getElementById('canvas');
            var ctx = null;

            if (canvas.getContext) {
                // 平稳退化
                ctx = canvas.getContext('2d');

                // 2. 载入图片
                var img = new Image();
                img.onload = function () {
                    // 3. 加载完成后，将图片绘制到画布
                    var posX = parseInt(canvas.width/2 - img.width/2),
                        posY = parseInt(canvas.height/2 - img.height/2);
                    ctx.drawImage(img, posX, posY);
 
                    // 4. 获取图像的像素信息
                    var imgData = ctx.getImageData(0, 0, img.width, img.height);

                    console.log(imgData);

                    var particles = [];
                    // 拣取部分像素粒子作为轮廓
                    function getparticles() {
                        // 按某一间隔拣取像素点
                        var particleSize_x = 1,
                            particleSize_y = 1;
                        var index = 0;  // 像素色值数组索引

                        for (var i = 0; i < img.width; i += particleSize_x) {
                            for (var j = 0; j < img.height; j += particleSize_y) {
                                index = (j * imgData.width + i) * 4;    // 第j行第i个像素，有四个色彩通道，所以 * 4
                                // 透明度值 > 125 的挑出来
                                if (imgData.data[index + 3] > 125) {
                                    var color = 'rgba(' + imgData.data[index] + ',' + imgData.data[index + 1] + ',' + imgData.data[index + 2] + ',' + imgData.data[index + 3] + ')';    
                                    var partical = {
                                        // 随机偏移一点点
                                        x: posX + i + (Math.random() - 0.5) * 20,
                                        y: posY + j + (Math.random() - 0.5) * 20,
                                        fillStyle: color
                                    }

                                    // 复合网格 & 色值筛选的粒子
                                    particles.push(partical);
                                }
                            }
                        }
                    }

                    // 绘制粒子轮廓
                    function draw() {
                        // 清空画布
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        var cur_partical = null;
                        for (var i = 0, length = particles.length; i < length; i++) {
                            cur_partical = particles[i];
                            ctx.fillStyle = cur_partical.fillStyle;
                            ctx.fillRect(cur_partical.x, cur_partical.y, 1, 1); // 粒子大小，即1 * 1
                        }
                    }

                    // 5. 执行粒子化过程
                    getparticles();
                    draw();
                };
                img.src= './img.png';
            }

        })();

    </script>
</body>
</html>